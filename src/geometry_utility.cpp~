// geometry_utility.cpp

#include "geometry_utility.hpp"
#include <cmath>

// Interpolation function matching Fortran's interp_p

// Ichoose = 1: full interpolation including normal, tangent vectors, metrics
void interp_p(
	      const Vec3* nodes,
	      double al, double be, double ga, double xi, double eta,
	      Vec3& pos, Vec3& DxDxi, Vec3& DxDet, Vec3& vn,
	      double& hxi, double& het, double& hs,
	      int Ichoose
	      ) {
  double ph1 = 2.0 * al - 1.0;
  double ph2 = 2.0 * be - 1.0;
  double ph3 = 2.0 * ga - 1.0;
  double ph4 = 4.0 * al * be;
  double ph5 = 4.0 * be * ga;
  double ph6 = 4.0 * ga * al;

  // Interpolated position
  pos = ph1 * nodes[0] + ph2 * nodes[1] + ph3 * nodes[2] +
    ph4 * nodes[3] + ph5 * nodes[4] + ph6 * nodes[5];

  if (Ichoose != 1) return;

  // Derivatives of shape functions w.r.t. al, be
  double dph1dal = 2.0, dph1dbe = 0.0;
  double dph2dal = 0.0, dph2dbe = 2.0;
  double dph3dal = -2.0, dph3dbe = -2.0;
  double dph4dal = 4.0 * be, dph4dbe = 4.0 * al;
  double dph5dal = 0.0, dph5dbe = 4.0 * ga;
  double dph6dal = 4.0 * ga, dph6dbe = -4.0 * al;

  // Derivatives of physical coordinates w.r.t. al, be
  Vec3 DxDal = dph1dal * nodes[0] + dph2dal * nodes[1] + dph3dal * nodes[2] +
    dph4dal * nodes[3] + dph5dal * nodes[4] + dph6dal * nodes[5];

  Vec3 DxDbe = dph1dbe * nodes[0] + dph2dbe * nodes[1] + dph3dbe * nodes[2] +
    dph4dbe * nodes[3] + dph5dbe * nodes[4] + dph6dbe * nodes[5];

  // Derivatives w.r.t. xi and eta
  DxDxi  = DxDal - DxDbe;
  DxDet  = DxDbe;

  // Normal vector
  vn = DxDxi.cross(DxDet);

  // Metric quantities
  hxi = DxDxi.norm();
  het = DxDet.norm();
  hs  = vn.norm();
}

